## 

---
title: "Lab 7 Assignement: Group 20"
author: Antoine Andréoletti (s242830), Olivier Gaufrès (243252), Amy Surry (201902), Lea Skytthe (s203531), Trine Søgaard (s204655)
format:
  html:
    embed-resources: true
editor: visual
---

## Data

The data we are using in this exercise comes from a paper from Gravier et al. (2020) and is available here: <https://github.com/ramhiser/datamicroarray/raw/master/data/gravier.RData>.

## Load Libraries

```{r}
#| message: False

library("tidyverse")
library("cowplot")
```

## Load data

```{r}
#| message: False

raw_dir <- "data/"
data_file <- "gravier.RData"
data_loc <- "https://github.com/ramhiser/datamicroarray/raw/master/data/"

if( !dir.exists(raw_dir) ){
  dir.create(path = raw_dir)
}
if( !file.exists(str_c(raw_dir, data_file)) ){
  download.file(
    url = str_c(data_loc, data_file),
    destfile = str_c(raw_dir, data_file))
}
load(file = str_c(raw_dir, data_file))
```

### Clean data

```{r}
#| echo: false
#| label: clean-data
gravier_clean <- gravier |>
  bind_cols() |>
  as_tibble()

gravier_clean_aug <- gravier_clean |>
  mutate(y = case_when(y == "poor" ~ 1,
                       y == "good" ~ 0)) |> 
  relocate(early_metastasis = y)
```

## Analyse data

We convert the data to tibble

```{r}
gravier_tibble <- gravier |>
  bind_cols() |> 
  as_tibble()
```

## Look at the data in PC coordinates

We start by running the PCA and storing the result in a variable `pca_fit`. There are two issues to consider here. First, the `prcomp()` function can only deal with numeric columns, so we need to remove all non-numeric columns from the data. This is straightforward using the `where(is.numeric)` tidyselect construct. Second, we normally want to scale the data values to unit variance before PCA. We do so by using the argument `scale = TRUE` in `prcomp()`.

```{r}
pca_fit <- gravier_tibble |> 
  select(where(is.numeric))  |>  # retain only numeric columns
  prcomp(scale = TRUE) # do PCA on scaled data
```

Now, we want to plot the data in PC coordinates. In general, this means combining the PC coordinates with the original dataset, so we can color points by categorical variables present in the original data but removed for the PCA.

```{r}
pca_fit |> 
  augment(gravier_tibble) |> 
  ggplot(aes(x = .fittedPC1, y = .fittedPC2, color = y)) + 
  geom_point(size = 1.5) +
  labs(color = "Condition",
       x = "PC1",
       y = "PC2")
```

## Look at the variance explained by each PC

Finally, we’ll plot the variance explained by each PC. We can again extract this information using the `tidy()` function from broom, now by setting the `matrix` argument to `matrix = "eigenvalues"`.

```{r}
pca_fit %>%
  tidy(matrix = "eigenvalues") %>%
  ggplot(aes(PC, percent)) +
  geom_col(fill = "#56B4E9", alpha = 0.8) +
  scale_y_continuous(
    labels = scales::percent_format(),
    expand = expansion(mult = c(0, 0.01))
  ) +
  theme_minimal_hgrid(12)
```

## Conclusion

In the gravier dataset, we have too many genes to extract relevant information with PCA. We should probably extract only significant genes first and repeat the same analysis.

### 

## Using only significant genes

See lecture 06 for more details.

### Get significant genes

```{r}
#| echo: false
#| label: significant-pca-gene-selection
genes <- colnames(gravier_clean_aug[-1])
gravier_clean_aug_long <- gravier_clean_aug |> 
  pivot_longer(cols = all_of(genes),
               values_to = "log2_expr_level",
               names_to = "gene")

gravier_estimates <- gravier_clean_aug_long |>
  group_by(gene) |>
  nest() |>
  mutate(model_object = map(
    .x = data,
    .f = ~ lm(log2_expr_level ~ early_metastasis,
              data = .x)),
    model_object_tidy = map(model_object,
                            ~tidy(.x, conf.int = TRUE,
                                  conf.level = 0.95))) |>
  unnest(model_object_tidy) |>
  filter(term  == "early_metastasis") |>
  select(gene, p.value, estimate, conf.low, conf.high) |>
  ungroup()

gravier_estimates <- gravier_estimates |> 
  mutate(q.value = p.adjust(p.value),
         significant = q.value < 0.05)

## Get the genes with a significant change
significant_genes <- gravier_estimates |> filter(significant == TRUE) |> pull(gene)

## Select the expression for these genes
gravier_significant <- gravier_clean |> select(all_of(significant_genes), y)

```

### PCA plot

```{r}
#| echo: false
#| label: significant-pca-plot
pca_fit_significant <- gravier_significant %>% 
  select(where(is.numeric)) %>% # retain only numeric columns
  prcomp(scale = TRUE) # do PCA on scaled data

pca_fit_significant %>%
  augment(gravier_significant) %>% # add original dataset back in
  ggplot(aes(.fittedPC1, .fittedPC2, color = y)) + 
  geom_point(size = 1.5) +
  scale_color_manual(
    values = c(poor = "#D55E00", good = "#0072B2")
  ) +
  theme_half_open(12) + background_grid()
```

### look at pc coordinates

```{r}
#| echo: false
#| label: significant-pca-coords
# extract rotation matrix
pca_fit_significant %>%
  tidy(matrix = "rotation")
```

```{r}
#| echo: false
#| label: significant-pca-coords-plot
# define arrow style for plotting
arrow_style <- arrow(
  angle = 20, ends = "first", type = "closed", length = grid::unit(8, "pt")
)

# plot rotation matrix
pca_fit_significant %>%
  tidy(matrix = "rotation") %>%
  pivot_wider(names_from = "PC", names_prefix = "PC", values_from = "value") %>%
  ggplot(aes(PC1, PC2)) +
  geom_segment(xend = 0, yend = 0, arrow = arrow_style) +
  geom_text(
    aes(label = column),
    hjust = 1, nudge_x = -0.02, 
    color = "#904C2F"
  ) +
  xlim(-1.25, .5) + ylim(-.5, 1) +
  coord_fixed() + # fix aspect ratio to 1:1
  theme_minimal_grid(12)
```

## Look at the variance explained by each PC

```{r}
#| echo: false
#| label: significant-pca-variance
pca_fit_significant %>%
  tidy(matrix = "eigenvalues")
```

```{r}
#| echo: false
#| label: significant-pca-variance-plot
pca_fit_significant %>%
  tidy(matrix = "eigenvalues") %>%
  ggplot(aes(PC, percent)) +
  geom_col(fill = "#56B4E9", alpha = 0.8) +
  scale_x_continuous(breaks = 1:9) +
  scale_y_continuous(
    labels = scales::percent_format(),
    expand = expansion(mult = c(0, 0.01))
  ) +
  theme_minimal_hgrid(12)
```

The 2 first components captures respectively 44.13% and 15.47% of the variation in the data.
